This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-05T11:50:22.985Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<directory_structure>
clevercloud/
  gradle.json
config/
  checkstyle/
    checkstyle.xml
  spotbugs/
    exclude.xml
gradle/
  wrapper/
    gradle-wrapper.properties
src/
  main/
    java/
      com/
        roomreservation/
          api/
            AccessController.java
            AuthController.java
            BookingController.java
            CardController.java
            RoomController.java
            UserController.java
          config/
            SecurityConfig.java
          mapper/
            BookingMapper.java
            CardMapper.java
            RoomMapper.java
            UserMapper.java
          model/
            BookingEntity.java
            CardEntity.java
            RoomEntity.java
            UserEntity.java
          record/
            AccessRequestRecord.java
            AccessResponseRecord.java
            BookingCommandRecord.java
            BookingRecord.java
            CardCommandRecord.java
            CardRecord.java
            LoginRequestRecord.java
            RoomRecord.java
            UserCommandRecord.java
            UserRecord.java
          repository/
            BookingDao.java
            CardDao.java
            RoomDao.java
            UserDao.java
          service/
            AccessService.java
            BookingService.java
            CardService.java
            RoomService.java
            UserService.java
          BookingConflictException.java
          RoomReservationApplication.java
          TransactionConfig.java
          WebConfig.java
    resources/
      application.properties
      data.sql
  test/
    java/
      com/
        roomreservation/
          AccessServiceTest.java
          BookingServiceTest.java
          RoomServiceTest.java
          UserServiceTest.java
build.gradle.kts
Dockerfile
gradlew
gradlew.bat
HELP.md
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="clevercloud/gradle.json">
{
  "build": {
    "type": "gradle",
    "goal": "assemble"
  },
  "deploy": {
    "jarName": "./build/libs/RoomReservation-0.0.1-SNAPSHOT.jar"
  }
}
</file>

<file path="config/checkstyle/checkstyle.xml">
<!DOCTYPE module PUBLIC "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN" "https://checkstyle.org/dtds/configuration_1_3.dtd">
<module name="Checker">
    <module name="TreeWalker">
        <module name="UnusedImports"/>
        <module name="MethodLength">
            <property name="max" value="50"/>
        </module>
        <module name="ParameterNumber">
            <property name="max" value="5"/>
        </module>
        <module name="CyclomaticComplexity">
            <property name="max" value="10"/>
        </module>
    </module>
</module>
</file>

<file path="config/spotbugs/exclude.xml">
<?xml version="1.0" encoding="UTF-8"?>
<FindBugsFilter>
    <!-- Ignore EI issues in data classes -->
    <Match>
        <Or>
            <Package name="~com\.roomreservation\.model.*"/>
            <Package name="~com\.roomreservation\.record.*"/>
            <Package name="~com\.roomreservation\.api.*"/>
            <Package name="~com\.roomreservation\.service.*"/>
        </Or>
        <Bug code="EI,EI2"/>
    </Match>
</FindBugsFilter>
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="src/main/java/com/roomreservation/api/AccessController.java">
package com.roomreservation.api;

import com.roomreservation.record.AccessRequestRecord;
import com.roomreservation.record.AccessResponseRecord;
import com.roomreservation.service.AccessService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * REST Controller handling room access validation requests.
 * Provides endpoints for validating card access to rooms.
 */
@CrossOrigin
@RestController
@RequestMapping("/access")
public class AccessController {
  
  @Autowired
  private AccessService accessService;
  
  /**
   * Validates whether a card has access to a specific room.
   *
   * @param requestRecord Contains the card number and room ID to validate
   * @return ResponseEntity with AccessResponseRecord indicating if access is granted
   */
  @PostMapping
  public ResponseEntity<AccessResponseRecord> validateAccess(@RequestBody AccessRequestRecord requestRecord) {
    AccessResponseRecord responseRecord = accessService.validateAccess(requestRecord);
    return ResponseEntity.ok(responseRecord);
  }
}
</file>

<file path="src/main/java/com/roomreservation/api/AuthController.java">
package com.roomreservation.api;

import com.roomreservation.mapper.UserMapper;
import com.roomreservation.model.UserEntity;
import com.roomreservation.record.LoginRequestRecord;
import com.roomreservation.record.UserRecord;
import com.roomreservation.service.UserService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/auth")
public class AuthController {
  private final UserService userService;
  
  public AuthController(UserService userService) {
    this.userService = userService;
  }
  
  @PostMapping("/login")
  public ResponseEntity<UserRecord> login(@RequestBody LoginRequestRecord loginRequest) {
    UserEntity user = userService.validateLogin(loginRequest.email(), loginRequest.password());
    return ResponseEntity.ok(UserMapper.of(user));
  }
}
</file>

<file path="src/main/java/com/roomreservation/api/BookingController.java">
package com.roomreservation.api;

import com.roomreservation.BookingConflictException;
import com.roomreservation.record.BookingCommandRecord;
import com.roomreservation.record.BookingRecord;
import com.roomreservation.service.BookingService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST Controller handling booking operations.
 * Provides endpoints for creating, updating, and managing room bookings.
 */
@CrossOrigin
@RestController
@RequestMapping("/api/bookings")
public class BookingController {
  
  private final BookingService bookingService;
  
  /**
   * Constructs a BookingController with required dependencies.
   * @param bookingService Service for handling booking operations
   */
  public BookingController(BookingService bookingService) {
    this.bookingService = bookingService;
  }
  
  /**
   * Retrieves all bookings in the system.
   * @return ResponseEntity containing list of all bookings
   */
  @GetMapping
  public ResponseEntity<List<BookingRecord>> getAllBookings() {
    return ResponseEntity.ok(bookingService.getAllBookings());
  }
  
  /**
   * Retrieves a specific booking by ID.
   * @param id ID of the booking to retrieve
   * @return ResponseEntity containing the requested booking
   */
  @GetMapping("/{id}")
  public ResponseEntity<BookingRecord> getBookingById(@PathVariable Long id) {
    return ResponseEntity.ok(bookingService.getBookingById(id));
  }
  
  @GetMapping("/user/{userId}")
  public ResponseEntity<List<BookingRecord>> getUserBookings(@PathVariable Long userId) {
    return ResponseEntity.ok(bookingService.getBookingsByUserId(userId));
  }
  
  /**
   * Creates a new booking.
   * @param bookingCommandRecord Details of the booking to create
   * @return ResponseEntity containing the created booking or error message
   */
  @PostMapping
  public ResponseEntity<?> createBooking(@RequestBody BookingCommandRecord bookingCommandRecord) {
    try {
      return ResponseEntity.ok(bookingService.createBooking(bookingCommandRecord));
    } catch (BookingConflictException e) {
      return ResponseEntity.status(409).body(e.getMessage());
    }
  }
  
  @DeleteMapping("/{id}")
  public ResponseEntity<Void> deleteBooking(@PathVariable Long id) {
    bookingService.deleteBooking(id);
    return ResponseEntity.noContent().build();
  }
  
  /**
   * Updates an existing booking.
   * @param id ID of the booking to update
   * @param bookingCommand Updated booking details
   * @return ResponseEntity containing the updated booking or error message
   */
  @PutMapping("/{id}")
  public ResponseEntity<?> updateBooking(@PathVariable Long id, @RequestBody BookingCommandRecord bookingCommand) {
    try {
      return ResponseEntity.ok(bookingService.updateBooking(id, bookingCommand));
    } catch (BookingConflictException e) {
      return ResponseEntity.status(409).body(e.getMessage());
    }
  }
}
</file>

<file path="src/main/java/com/roomreservation/api/CardController.java">
package com.roomreservation.api;

import com.roomreservation.record.CardRecord;
import com.roomreservation.service.CardService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@CrossOrigin
@RestController
@RequestMapping("/api/cards")
public class CardController {
  
  private final CardService cardService;
  
  public CardController(CardService cardService) {
    this.cardService = cardService;
  }
  
  @GetMapping
  public ResponseEntity<List<CardRecord>> getAllCards() {
    return ResponseEntity.ok(cardService.getAllCards());
  }
  
}
</file>

<file path="src/main/java/com/roomreservation/api/RoomController.java">
package com.roomreservation.api;

import com.roomreservation.record.RoomRecord;
import com.roomreservation.service.RoomService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@CrossOrigin
@RestController
@RequestMapping("/api/rooms")
public class RoomController {
  
  private final RoomService roomService;
  
  public RoomController(RoomService roomService) {
    this.roomService = roomService;
  }
  
  @GetMapping
  public ResponseEntity<List<RoomRecord>> getAllRooms() {
    return ResponseEntity.ok(roomService.getAllRooms());
  }
  
  @GetMapping("/{id}")
  public ResponseEntity<RoomRecord> getRoomById(@PathVariable Long id) {
    return ResponseEntity.ok(roomService.getRoomById(id));
  }
  
  @PostMapping
  public ResponseEntity<RoomRecord> createRoom(@RequestBody RoomRecord roomCommand) {
    return ResponseEntity.ok(roomService.createRoom(roomCommand));
  }
  
  @PutMapping("/{id}")
  public ResponseEntity<RoomRecord> updateRoom(@PathVariable Long id, @RequestBody RoomRecord roomCommand) {
    return ResponseEntity.ok(roomService.updateRoom(id, roomCommand));
  }
  
  @DeleteMapping("/{id}")
  public ResponseEntity<Void> deleteRoom(@PathVariable Long id) {
    roomService.deleteRoom(id);
    return ResponseEntity.noContent().build();
  }
}
</file>

<file path="src/main/java/com/roomreservation/api/UserController.java">
package com.roomreservation.api;

import com.roomreservation.mapper.UserMapper;
import com.roomreservation.model.UserEntity;
import com.roomreservation.record.UserCommandRecord;
import com.roomreservation.record.UserRecord;
import com.roomreservation.service.UserService;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Set;

@CrossOrigin
@RestController
@RequestMapping("/api/users")
public class UserController {
  
  @Autowired
  private UserService userService;
  
  @Autowired
  private Validator validator;
  
  @GetMapping
  public ResponseEntity<List<UserRecord>> getAllUsers() {
    return ResponseEntity.ok(userService.getAllUsers());
  }
  
  @GetMapping("/{id}")
  public ResponseEntity<UserRecord> getUserById(@PathVariable Long id) {
    return ResponseEntity.ok(UserMapper.of(userService.getUserById(id)));
  }
  
  @PostMapping
  public ResponseEntity<Object> createUser(@Validated @RequestBody UserCommandRecord userCommand) {
    try {
      UserEntity entity = new UserEntity();
      entity.setFirstName(userCommand.firstName());
      entity.setLastName(userCommand.lastName());
      entity.setEmail(userCommand.email());
      entity.setPassword(userCommand.password());
      
      // Validate the entity
      Set<ConstraintViolation<UserEntity>> violations = validator.validate(entity);
      if (!violations.isEmpty()) {
        // Get the first validation error message
        String errorMessage = violations.iterator().next().getMessage();
        if (errorMessage.contains("Email")) {
          return ResponseEntity.badRequest().body("Incorrect email format");
        }
        return ResponseEntity.badRequest().body(errorMessage);
      }
      
      UserEntity createdUser = userService.createUser(entity);
      return ResponseEntity.status(201).body(UserMapper.of(createdUser));
    } catch (RuntimeException e) {
      if (e.getMessage().contains("Email already exists")) {
        return ResponseEntity.badRequest().body("Email already exists");
      }
      return ResponseEntity.badRequest().body("An error occurred while creating the user");
    }
  }
  
  @PutMapping("/{id}")
  public ResponseEntity<UserRecord> updateUser(@PathVariable Long id, @Validated @RequestBody UserCommandRecord userCommand) {
    UserEntity entity = new UserEntity();
    entity.setFirstName(userCommand.firstName());
    entity.setLastName(userCommand.lastName());
    entity.setEmail(userCommand.email());
    entity.setPassword(userCommand.password());
    
    UserEntity updatedUser = userService.updateUser(id, entity);
    return ResponseEntity.ok(UserMapper.of(updatedUser));
  }
  
  @DeleteMapping("/{id}")
  public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
    userService.deleteUser(id);
    return ResponseEntity.noContent().build();
  }
}
</file>

<file path="src/main/java/com/roomreservation/config/SecurityConfig.java">
package com.roomreservation.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
      .csrf(AbstractHttpConfigurer::disable)
      .headers(headers -> headers
        .frameOptions(HeadersConfigurer.FrameOptionsConfig::disable))
      .authorizeHttpRequests(authorize -> authorize
        .anyRequest().permitAll());
    return http.build();
  }
}
</file>

<file path="src/main/java/com/roomreservation/mapper/BookingMapper.java">
package com.roomreservation.mapper;

import com.roomreservation.model.BookingEntity;
import com.roomreservation.record.BookingRecord;

public class BookingMapper {
  public static BookingRecord of(BookingEntity bookingEntity) {
    return new BookingRecord(
      bookingEntity.getId(),
      bookingEntity.getStartTime(),
      bookingEntity.getEndTime(),
      bookingEntity.getRoomEntity().getId(),
      bookingEntity.getRoomEntity().getName(),
      bookingEntity.getUserEntity().getId()
    );
  }
}
</file>

<file path="src/main/java/com/roomreservation/mapper/CardMapper.java">
package com.roomreservation.mapper;

import com.roomreservation.model.CardEntity;
import com.roomreservation.record.CardRecord;

public class CardMapper {
  public static CardRecord of(CardEntity cardEntity) {
    return new CardRecord(
      cardEntity.getId(),
      cardEntity.getCardNumber(),
      cardEntity.getUserEntity().getId()
    );
  }
}
</file>

<file path="src/main/java/com/roomreservation/mapper/RoomMapper.java">
package com.roomreservation.mapper;

import com.roomreservation.model.RoomEntity;
import com.roomreservation.record.RoomRecord;

public class RoomMapper {
  public static RoomRecord of(RoomEntity roomEntity) {
    return new RoomRecord(
      roomEntity.getId(),
      roomEntity.getName(),
      roomEntity.getCapacity(),
      roomEntity.getBookingEntities()
    );
  }
}
</file>

<file path="src/main/java/com/roomreservation/mapper/UserMapper.java">
package com.roomreservation.mapper;

import com.roomreservation.model.UserEntity;
import com.roomreservation.record.UserRecord;

/**
 * Utility class for mapping between User entities and DTOs.
 * Provides conversion methods to transform UserEntity objects to UserRecord objects.
 */
public class UserMapper {
  
  /**
   * Converts a UserEntity to its DTO representation.
   * @param userEntity The user entity to convert
   * @return UserRecord containing the user's data
   */
  public static UserRecord of(UserEntity userEntity) {
    return new UserRecord(
      userEntity.getId(),
      userEntity.getFirstName(),
      userEntity.getLastName(),
      userEntity.getEmail(),
      userEntity.getPassword(),
      userEntity.getCardEntity() != null ? userEntity.getCardEntity().getId() : null
    );
  }
}
</file>

<file path="src/main/java/com/roomreservation/model/BookingEntity.java">
package com.roomreservation.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * Entity representing a room booking in the system.
 * A booking associates a user with a room for a specific time period.
 */
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "SP_BOOKING")
public class BookingEntity {
  
  /**
   * Unique identifier for the booking
   */
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  
  /**
   * Start time of the booking
   */
  @Column(nullable = false)
  private LocalDateTime startTime;
  
  /**
   * End time of the booking
   */
  @Column(nullable = false)
  private LocalDateTime endTime;
  
  /**
   * The room that is booked
   */
  @ManyToOne
  @JoinColumn(name = "room_id", nullable = false)
  private RoomEntity roomEntity;
  
  /**
   * The user who made the booking
   */
  @ManyToOne
  @JoinColumn(name = "user_id", nullable = false)
  private UserEntity userEntity;
}
</file>

<file path="src/main/java/com/roomreservation/model/CardEntity.java">
package com.roomreservation.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "SP_CARD")
public class CardEntity {
  
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  
  @Column(nullable = false, unique = true)
  private String cardNumber;
  
  @OneToOne
  @JoinColumn(name = "user_id", nullable = false, unique = true)
  private UserEntity userEntity;
}
</file>

<file path="src/main/java/com/roomreservation/model/RoomEntity.java">
package com.roomreservation.model;

import com.roomreservation.mapper.BookingMapper;
import com.roomreservation.record.BookingRecord;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "SP_ROOM")
public class RoomEntity {
  
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  
  @Column(nullable = false)
  private String name;
  
  @Column(nullable = false)
  private int capacity;
  
  @OneToMany(mappedBy = "roomEntity", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<BookingEntity> bookingEntities = new ArrayList<>();
  
  public List<BookingRecord> getBookingEntities() {
    return bookingEntities.stream().map(BookingMapper::of).collect(Collectors.toList());
  }
}
</file>

<file path="src/main/java/com/roomreservation/model/UserEntity.java">
package com.roomreservation.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Entity representing a user in the system.
 * Contains user profile information and associated access card details.
 */
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "SP_USER")
public class UserEntity {
  
  /**
   * Unique identifier for the user
   */
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Column(name = "id", nullable = false, updatable = false)
  private Long id;
  
  /**
   * User's first name
   */
  @NotNull
  private String firstName;
  
  /**
   * User's last name
   */
  @NotNull
  private String lastName;
  
  /**
   * User's email address (must be unique)
   */
  @NotNull
  @Email(message = "Incorrect email format")
  @Column(unique = true)
  private String email;
  
  /**
   * User's password
   */
  @NotNull
  private String password;
  
  /**
   * User's associated access card
   */
  @OneToOne(mappedBy = "userEntity", cascade = CascadeType.ALL, orphanRemoval = true)
  private CardEntity cardEntity;
}
</file>

<file path="src/main/java/com/roomreservation/record/AccessRequestRecord.java">
package com.roomreservation.record;

public record AccessRequestRecord(String cardNumber, Long roomId) {}
</file>

<file path="src/main/java/com/roomreservation/record/AccessResponseRecord.java">
package com.roomreservation.record;

public record AccessResponseRecord(boolean accessGranted) {}
</file>

<file path="src/main/java/com/roomreservation/record/BookingCommandRecord.java">
package com.roomreservation.record;

import java.time.LocalDateTime;

public record BookingCommandRecord(
  LocalDateTime startTime,
  LocalDateTime endTime,
  Long roomId,
  Long userId
) {}
</file>

<file path="src/main/java/com/roomreservation/record/BookingRecord.java">
package com.roomreservation.record;

import java.time.LocalDateTime;

public record BookingRecord(
  Long id,
  LocalDateTime startTime,
  LocalDateTime endTime,
  Long roomId,
  String roomName,
  Long userId
) {}
</file>

<file path="src/main/java/com/roomreservation/record/CardCommandRecord.java">
package com.roomreservation.record;

public record CardCommandRecord(
  String cardNumber,
  Long userId
) {}
</file>

<file path="src/main/java/com/roomreservation/record/CardRecord.java">
package com.roomreservation.record;

public record CardRecord(
  Long id,
  String cardNumber,
  Long userId
) {}
</file>

<file path="src/main/java/com/roomreservation/record/LoginRequestRecord.java">
package com.roomreservation.record;

public record LoginRequestRecord(String email, String password) {}
</file>

<file path="src/main/java/com/roomreservation/record/RoomRecord.java">
package com.roomreservation.record;

import java.util.List;

public record RoomRecord(
  Long id,
  String name,
  int capacity,
  List<BookingRecord> bookings
) {}
</file>

<file path="src/main/java/com/roomreservation/record/UserCommandRecord.java">
package com.roomreservation.record;

public record UserCommandRecord(
  String firstName,
  String lastName,
  String email,
  String password
) {}
</file>

<file path="src/main/java/com/roomreservation/record/UserRecord.java">
package com.roomreservation.record;

public record UserRecord(
  Long id,
  String firstName,
  String lastName,
  String email,
  String password,
  Long cardId
) {}
</file>

<file path="src/main/java/com/roomreservation/repository/BookingDao.java">
package com.roomreservation.repository;

import com.roomreservation.model.BookingEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.time.LocalDateTime;
import java.util.List;

public interface BookingDao extends JpaRepository<BookingEntity, Long> {
  List<BookingEntity> findByRoomEntityId(Long roomId);
  
  List<BookingEntity> findByUserEntityId(Long userId);
  
  @Query("SELECT b FROM BookingEntity b " +
    "WHERE b.userEntity.cardEntity.cardNumber = :cardNumber " +
    "AND b.roomEntity.id = :roomId " +
    "AND b.startTime <= :now " +
    "AND b.endTime >= :now")
  BookingEntity findValidBooking(String cardNumber, Long roomId, LocalDateTime now);
}
</file>

<file path="src/main/java/com/roomreservation/repository/CardDao.java">
package com.roomreservation.repository;

import com.roomreservation.model.CardEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface CardDao extends JpaRepository<CardEntity, Long> {
  Optional<CardEntity> findByCardNumber(String cardNumber);
}
</file>

<file path="src/main/java/com/roomreservation/repository/RoomDao.java">
package com.roomreservation.repository;

import com.roomreservation.model.RoomEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface RoomDao extends JpaRepository<RoomEntity, Long> { }
</file>

<file path="src/main/java/com/roomreservation/repository/UserDao.java">
package com.roomreservation.repository;

import com.roomreservation.model.UserEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserDao extends JpaRepository<UserEntity, Long> {
  UserEntity findByEmailIgnoreCase(String email);
}
</file>

<file path="src/main/java/com/roomreservation/service/AccessService.java">
package com.roomreservation.service;

import com.roomreservation.model.BookingEntity;
import com.roomreservation.record.AccessRequestRecord;
import com.roomreservation.record.AccessResponseRecord;
import com.roomreservation.repository.BookingDao;
import com.roomreservation.repository.CardDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class AccessService {
  
  @Autowired
  private BookingDao bookingDao;
  
  @Autowired
  private CardDao cardDao;
  
  public AccessResponseRecord validateAccess(AccessRequestRecord requestRecord) {
    String cardNumber = requestRecord.cardNumber();
    Long roomId = requestRecord.roomId();
    LocalDateTime now = LocalDateTime.now();
    
    System.out.println("Debug - Card Number: " + cardNumber);
    System.out.println("Debug - Room ID: " + roomId);
    System.out.println("Debug - Current Time: " + now);
    
    // Validate card exists
    if (!cardDao.findByCardNumber(cardNumber).isPresent()) {
      System.out.println("Debug - Card not found");
      return new AccessResponseRecord(false);
    }
    
    // Validate booking
    BookingEntity booking = bookingDao.findValidBooking(cardNumber, roomId, now);
    System.out.println("Debug - Booking found: " + (booking != null));
    
    return new AccessResponseRecord(booking != null);
  }
}
</file>

<file path="src/main/java/com/roomreservation/service/BookingService.java">
package com.roomreservation.service;

import com.roomreservation.BookingConflictException;
import com.roomreservation.mapper.BookingMapper;
import com.roomreservation.model.BookingEntity;
import com.roomreservation.model.RoomEntity;
import com.roomreservation.model.UserEntity;
import com.roomreservation.record.BookingCommandRecord;
import com.roomreservation.record.BookingRecord;
import com.roomreservation.repository.BookingDao;
import com.roomreservation.repository.RoomDao;
import com.roomreservation.repository.UserDao;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class BookingService {
  
  private final BookingDao bookingDao;
  private final RoomDao roomDao;
  private final UserDao userDao;
  private final RoomService roomService;
  
  public BookingService(BookingDao bookingDao, RoomDao roomDao, UserDao userDao, RoomService roomService) {
    this.bookingDao = bookingDao;
    this.roomDao = roomDao;
    this.userDao = userDao;
    this.roomService = roomService;
  }
  
  public List<BookingRecord> getAllBookings() {
    return bookingDao.findAll().stream()
      .map(BookingMapper::of)
      .collect(Collectors.toList());
  }
  
  public BookingRecord getBookingById(Long id) {
    BookingEntity bookingEntity = bookingDao.findById(id)
      .orElseThrow(() -> new RuntimeException("BookingEntity not found"));
    return BookingMapper.of(bookingEntity);
  }
  
  @Transactional
  public BookingRecord createBooking(BookingCommandRecord bookingCommand) {
    try {
      validateBookingTime(bookingCommand.startTime(), bookingCommand.endTime());
      
      if (hasConflictingBookings(bookingCommand.roomId(), bookingCommand.startTime(),
        bookingCommand.endTime(), -1L)) {
        throw new BookingConflictException("Room is already booked for this time slot");
      }
      
      RoomEntity room = roomDao.findById(bookingCommand.roomId())
        .orElseThrow(() -> new RuntimeException("Room not found"));
      
      UserEntity user = userDao.findById(bookingCommand.userId())
        .orElseThrow(() -> new RuntimeException("User not found"));
      
      if (!roomService.getAvailableRooms(bookingCommand.startTime(), bookingCommand.endTime())
        .stream()
        .anyMatch(r -> r.id().equals(room.getId()))) {
        throw new RuntimeException("Room is not available for the selected time slot");
      }
      
      BookingEntity booking = new BookingEntity();
      booking.setStartTime(bookingCommand.startTime());
      booking.setEndTime(bookingCommand.endTime());
      booking.setRoomEntity(room);
      booking.setUserEntity(user);
      
      return BookingMapper.of(bookingDao.save(booking));
    
    } catch (BookingConflictException e) {
      throw e;
    } catch (Exception e) {
      throw new RuntimeException("Error creating booking: " + e.getMessage());
    }
  }
  
  private void validateBookingTime(LocalDateTime startTime, LocalDateTime endTime) {
//    if (startTime.isBefore(LocalDateTime.now())) {
//      throw new RuntimeException("Cannot book in the past");
//    }
    if (endTime.isBefore(startTime)) {
      throw new RuntimeException("End time must be after start time");
    }
//    if (startTime.plusHours(4).isBefore(endTime)) {
//      throw new RuntimeException("Maximum booking duration is 4 hours");
//    }
  }
  
  public void deleteBooking(Long id) {
    bookingDao.deleteById(id);
  }
  
  public List<BookingRecord> getBookingsByUserId(Long userId) {
    return bookingDao.findByUserEntityId(userId).stream()
      .map(BookingMapper::of)
      .collect(Collectors.toList());
  }
  
  @Transactional
  public BookingRecord updateBooking(Long id, BookingCommandRecord bookingCommand) {
    try {
      validateBookingTime(bookingCommand.startTime(), bookingCommand.endTime());
      
      if (hasConflictingBookings(bookingCommand.roomId(), bookingCommand.startTime(),
        bookingCommand.endTime(), id)) {
        throw new BookingConflictException("Room is already booked for this time slot");
      }
      
      BookingEntity booking = bookingDao.findById(id)
        .orElseThrow(() -> new RuntimeException("Booking not found"));
      
      validateBookingTime(bookingCommand.startTime(), bookingCommand.endTime());
      
      RoomEntity room = roomDao.findById(bookingCommand.roomId())
        .orElseThrow(() -> new RuntimeException("Room not found"));
      
      if (!booking.getUserEntity().getId().equals(bookingCommand.userId())) {
        throw new RuntimeException("Cannot modify booking owned by another user");
      }
      
      if (!room.getId().equals(booking.getRoomEntity().getId()) &&
        !roomService.getAvailableRooms(bookingCommand.startTime(), bookingCommand.endTime())
          .stream()
          .anyMatch(r -> r.id().equals(room.getId()))) {
        throw new RuntimeException("Room is not available for the selected time slot");
      }
      
      booking.setStartTime(bookingCommand.startTime());
      booking.setEndTime(bookingCommand.endTime());
      booking.setRoomEntity(room);
      
      return BookingMapper.of(bookingDao.save(booking));
      
    } catch (BookingConflictException e) {
      throw e;
    } catch (Exception e) {
      throw new RuntimeException("Error updating booking: " + e.getMessage());
    }
  }
  
  private boolean hasConflictingBookings(Long roomId, LocalDateTime startTime, LocalDateTime endTime, Long excludeBookingId) {
    return bookingDao.findByRoomEntityId(roomId).stream()
      .filter(booking -> !booking.getId().equals(excludeBookingId))
      .anyMatch(booking ->
        (startTime.isBefore(booking.getEndTime()) || startTime.isEqual(booking.getEndTime())) &&
          (endTime.isAfter(booking.getStartTime()) || endTime.isEqual(booking.getStartTime()))
      );
  }
}
</file>

<file path="src/main/java/com/roomreservation/service/CardService.java">
package com.roomreservation.service;

import com.roomreservation.mapper.CardMapper;
import com.roomreservation.model.CardEntity;
import com.roomreservation.model.UserEntity;
import com.roomreservation.record.CardCommandRecord;
import com.roomreservation.record.CardRecord;
import com.roomreservation.repository.CardDao;
import com.roomreservation.repository.UserDao;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class CardService {
  
  private final CardDao cardDao;
  private final UserDao userDao;
  
  public CardService(CardDao cardDao, UserDao userDao) {
    this.cardDao = cardDao;
    this.userDao = userDao;
  }
  
  public List<CardRecord> getAllCards() {
    return cardDao.findAll().stream()
      .map(CardMapper::of)
      .collect(Collectors.toList());
  }
  
  @Transactional
  public CardEntity assignCardToUser(Long userId, CardCommandRecord cardCommand) {
    UserEntity userEntity = userDao.findById(userId)
      .orElseThrow(() -> new RuntimeException("User not found"));
    
    if (cardDao.findByCardNumber(cardCommand.cardNumber()).isPresent()) {
      throw new RuntimeException("Card number already exists");
    }
    
    if (userEntity.getCardEntity() != null) {
      cardDao.delete(userEntity.getCardEntity());
      userEntity.setCardEntity(null);
    }
    
    CardEntity cardEntity = new CardEntity();
    cardEntity.setCardNumber(cardCommand.cardNumber());
    cardEntity.setUserEntity(userEntity);
    userEntity.setCardEntity(cardEntity);
    
    userDao.save(userEntity);
    return cardDao.save(cardEntity);
  }
}
</file>

<file path="src/main/java/com/roomreservation/service/RoomService.java">
package com.roomreservation.service;

import com.roomreservation.mapper.RoomMapper;
import com.roomreservation.model.RoomEntity;
import com.roomreservation.record.BookingRecord;
import com.roomreservation.record.RoomRecord;
import com.roomreservation.repository.BookingDao;
import com.roomreservation.repository.RoomDao;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service class managing room-related operations.
 * Handles room creation, updates, deletions, and availability checks.
 */
@Service
public class RoomService {
  
  private final RoomDao roomDao;
  private final BookingDao bookingDao;
  
  /**
   * Constructs a RoomService with required dependencies.
   * @param roomDao Data access object for room operations
   * @param bookingDao Data access object for booking operations
   */
  public RoomService(RoomDao roomDao, BookingDao bookingDao) {
    this.roomDao = roomDao;
    this.bookingDao = bookingDao;
  }
  
  /**
   * Retrieves all rooms in the system.
   * @return List of RoomRecord objects representing all rooms
   */
  public List<RoomRecord> getAllRooms() {
    return roomDao.findAll().stream()
      .map(RoomMapper::of)
      .collect(Collectors.toList());
  }
  
  /**
   * Retrieves a room by its ID.
   * @param id The ID of the room to retrieve
   * @return RoomRecord representing the requested room
   * @throws RuntimeException if room is not found
   */
  public RoomRecord getRoomById(Long id) {
    RoomEntity roomEntity = roomDao.findById(id)
      .orElseThrow(() -> new RuntimeException("RoomEntity not found"));
    return RoomMapper.of(roomEntity);
  }
  
  /**
   * Creates a new room.
   * @param roomRecord Room details including name and capacity
   * @return RoomRecord representing the created room
   */
  public RoomRecord createRoom(RoomRecord roomRecord) {
    RoomEntity roomEntity = new RoomEntity();
    roomEntity.setName(roomRecord.name());
    roomEntity.setCapacity(roomRecord.capacity());
    RoomEntity savedRoomEntity = roomDao.save(roomEntity);
    return RoomMapper.of(savedRoomEntity);
  }
  
  public RoomRecord updateRoom(Long id, RoomRecord roomRecord) {
    RoomEntity roomEntity = roomDao.findById(id)
      .orElseThrow(() -> new RuntimeException("RoomEntity not found"));
    roomEntity.setName(roomRecord.name());
    roomEntity.setCapacity(roomRecord.capacity());
    RoomEntity updatedRoomEntity = roomDao.save(roomEntity);
    return RoomMapper.of(updatedRoomEntity);
  }
  
  public void deleteRoom(Long id) {
    roomDao.deleteById(id);
  }
  
  /**
   * Checks room availability for a given time period.
   * @param startTime Start of the time period to check
   * @param endTime End of the time period to check
   * @return List of RoomRecord objects representing available rooms
   */
  public List<RoomRecord> getAvailableRooms(LocalDateTime startTime, LocalDateTime endTime) {
    List<RoomEntity> allRooms = roomDao.findAll();
    return allRooms.stream()
      .filter(room -> isRoomAvailable(room, startTime, endTime))
      .map(RoomMapper::of)
      .collect(Collectors.toList());
  }
  
  private boolean isRoomAvailable(RoomEntity room, LocalDateTime startTime, LocalDateTime endTime) {
    List<BookingRecord> bookings = room.getBookingEntities();
    return bookings.stream()
      .noneMatch(booking ->
        (startTime.isBefore(booking.endTime()) || startTime.isEqual(booking.endTime())) &&
          (endTime.isAfter(booking.startTime()) || endTime.isEqual(booking.startTime()))
      );
  }
}
</file>

<file path="src/main/java/com/roomreservation/service/UserService.java">
package com.roomreservation.service;

import com.roomreservation.mapper.UserMapper;
import com.roomreservation.model.CardEntity;
import com.roomreservation.model.UserEntity;
import com.roomreservation.record.UserRecord;
import com.roomreservation.repository.CardDao;
import com.roomreservation.repository.UserDao;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service class handling user operations including creation, authentication, and management.
 * This service manages user accounts and their associated access cards.
 */
@Transactional
@Service
public class UserService {
  private final UserDao userDao;
  private final CardDao cardDao;
//  private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
  
  /**
   * Constructs a new UserService with required dependencies.
   * @param userDao Data access object for user operations
   * @param cardDao Data access object for card operations
   */
  public UserService(UserDao userDao, CardDao cardDao) {
    this.userDao = userDao;
    this.cardDao = cardDao;
  }
  
  /**
   * Retrieves all users in the system.
   * @return List of UserRecord objects representing all users
   */
  public List<UserRecord> getAllUsers() {
    return userDao.findAll().stream()
      .map(UserMapper::of)
      .collect(Collectors.toList());
  }
  
  public UserEntity getUserById(Long id) {
    return userDao.findById(id).orElseThrow(() -> new RuntimeException("UserEntity not found"));
  }
  
  /**
   * Creates a new user with an associated access card.
   * @param userEntity User details including name, email, and password
   * @return UserEntity The created user with generated card
   * @throws RuntimeException if email already exists
   */
  @Transactional
  public UserEntity createUser(UserEntity userEntity) {
    if (userDao.findByEmailIgnoreCase(userEntity.getEmail()) != null) {
      throw new RuntimeException("Email already exists");
    }
    
    userEntity.setId(null);
//    userEntity.setPassword(passwordEncoder.encode(userEntity.getPassword()));
    userEntity.setPassword(userEntity.getPassword());
    UserEntity savedUser = userDao.save(userEntity);
    
    CardEntity cardEntity = new CardEntity();
    cardEntity.setCardNumber("CARD-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase());
    cardEntity.setUserEntity(savedUser);
    
    savedUser.setCardEntity(cardEntity);
    cardDao.save(cardEntity);
    
    return userDao.save(savedUser);
  }
  
  private String generateCardNumber() {
    return "CARD-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
  }
  
  public UserEntity updateUser(Long id, UserEntity userEntityDetails) {
    UserEntity userEntity = getUserById(id);
    userEntity.setFirstName(userEntityDetails.getFirstName());
    userEntity.setLastName(userEntityDetails.getLastName());
    userEntity.setEmail(userEntityDetails.getEmail());
    userEntity.setPassword(userEntityDetails.getPassword());
    return userDao.save(userEntity);
  }
  
  public void deleteUser(Long id) {
    userDao.deleteById(id);
  }
  
  /**
   * Validates user login credentials.
   * @param email User's email address
   * @param password User's password
   * @return UserEntity if validation succeeds
   * @throws RuntimeException if credentials are invalid
   */
  public UserEntity validateLogin(String email, String password) {
    UserEntity user = userDao.findByEmailIgnoreCase(email);
//    if (user == null || !passwordEncoder.matches(password, user.getPassword())) {
    if (user == null || !password.equals(user.getPassword())) {
      throw new RuntimeException("Invalid email or password");
    }
    return user;
  }
}
</file>

<file path="src/main/java/com/roomreservation/BookingConflictException.java">
package com.roomreservation;

public class BookingConflictException extends RuntimeException {
  public BookingConflictException(String message) {
    super(message);
  }
}
</file>

<file path="src/main/java/com/roomreservation/RoomReservationApplication.java">
package com.roomreservation;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class RoomReservationApplication {
  
  public static void main(String[] args) {
    SpringApplication.run(RoomReservationApplication.class, args);
  }
  
}
</file>

<file path="src/main/java/com/roomreservation/TransactionConfig.java">
package com.roomreservation;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
public class TransactionConfig {
  
  @Primary
  @Bean
  public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
    return new JpaTransactionManager(entityManagerFactory);
  }
}
</file>

<file path="src/main/java/com/roomreservation/WebConfig.java">
package com.roomreservation;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
  @Override
  public void addCorsMappings(CorsRegistry registry) {
    registry.addMapping("/**")
      .allowedOrigins("*")  // Or specify your frontend URL
      .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
      .allowedHeaders("*")
      .maxAge(3600);
  }
}
</file>

<file path="src/main/resources/application.properties">
spring.application.name=RoomReservation

logging.level.org.springframework.web=DEBUG
logging.level.com.roomreservation=DEBUG

# Spring boot : configure H2 datasource
spring.datasource.url=jdbc:h2:mem:roomReservation;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.username=sa
spring.datasource.password=
spring.datasource.driverClassName=org.h2.Driver

# Spring boot : activate H2 console
spring.h2.console.enabled=true
spring.h2.console.path=/console

# Spring boot : JPA
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.generate-ddl=true
spring.jpa.show_sql=true
spring.jpa.defer-datasource-initialization=true
spring.jpa.hibernate.ddl-auto=create-drop

spring.mvc.pathmatch.matching-strategy=ant_path_matcher
</file>

<file path="src/main/resources/data.sql">
INSERT INTO SP_USER (first_name, last_name, email, password) VALUES
                                                                 ('Test', 'User1', 'test1@test.com', 'test'),
                                                                 ('Test', 'User2', 'test2@test.com', 'test');

-- Insert corresponding cards
INSERT INTO SP_CARD (card_number, user_id) VALUES
                                                       ('49F18AAA', (SELECT id FROM SP_USER WHERE email = 'test1@test.com')),
                                                       ('F515CE10', (SELECT id FROM SP_USER WHERE email = 'test2@test.com'));

-- Insert mock rooms
INSERT INTO SP_ROOM (name, capacity) VALUES
                                                    ('Conference Room A', 10),
                                                    ('Conference Room B', 10),
                                                    ('Conference Room C', 10),
                                                    ('Meeting Room A', 5),
                                                    ('Meeting Room B', 5),
                                                    ('Meeting Room C', 5);
</file>

<file path="src/test/java/com/roomreservation/AccessServiceTest.java">
package com.roomreservation;

import com.roomreservation.model.BookingEntity;
import com.roomreservation.model.CardEntity;
import com.roomreservation.model.RoomEntity;
import com.roomreservation.model.UserEntity;
import com.roomreservation.record.AccessRequestRecord;
import com.roomreservation.record.AccessResponseRecord;
import com.roomreservation.repository.BookingDao;
import com.roomreservation.repository.CardDao;
import com.roomreservation.service.AccessService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class AccessServiceTest {
  @Mock
  private BookingDao bookingDao;
  
  @Mock
  private CardDao cardDao;
  
  @InjectMocks
  private AccessService accessService;
  
  private BookingEntity mockBooking;
  private CardEntity mockCard;
  private UserEntity mockUser;
  private RoomEntity mockRoom;
  private static final String VALID_CARD_NUMBER = "CARD-TEST001";
  
  @BeforeEach
  void setUp() {
    // Setup mock user
    mockUser = new UserEntity();
    mockUser.setId(1L);
    mockUser.setEmail("test@test.com");
    
    // Setup mock card
    mockCard = new CardEntity();
    mockCard.setId(1L);
    mockCard.setCardNumber(VALID_CARD_NUMBER);
    mockCard.setUserEntity(mockUser);
    
    // Setup mock room
    mockRoom = new RoomEntity();
    mockRoom.setId(1L);
    mockRoom.setName("Test Room");
    
    // Setup mock booking
    mockBooking = new BookingEntity();
    mockBooking.setId(1L);
    mockBooking.setStartTime(LocalDateTime.now().minusHours(1));
    mockBooking.setEndTime(LocalDateTime.now().plusHours(1));
    mockBooking.setRoomEntity(mockRoom);
    mockBooking.setUserEntity(mockUser);
  }
  
  @Test
  void validateAccess_Success() {
    // Arrange
    Long roomId = 1L;
    AccessRequestRecord request = new AccessRequestRecord(VALID_CARD_NUMBER, roomId);
    
    when(cardDao.findByCardNumber(VALID_CARD_NUMBER)).thenReturn(Optional.of(mockCard));
    when(bookingDao.findValidBooking(eq(VALID_CARD_NUMBER), eq(roomId), any(LocalDateTime.class)))
      .thenReturn(mockBooking);
    
    // Act
    AccessResponseRecord response = accessService.validateAccess(request);
    
    // Assert
    assertTrue(response.accessGranted());
  }
  
  @Test
  void validateAccess_InvalidCard() {
    // Arrange
    String invalidCardNumber = "INVALID-CARD";
    Long roomId = 1L;
    AccessRequestRecord request = new AccessRequestRecord(invalidCardNumber, roomId);
    
    when(cardDao.findByCardNumber(invalidCardNumber)).thenReturn(Optional.empty());
    
    // Act
    AccessResponseRecord response = accessService.validateAccess(request);
    
    // Assert
    assertFalse(response.accessGranted());
  }
  
  @Test
  void validateAccess_NoValidBooking() {
    // Arrange
    Long roomId = 1L;
    AccessRequestRecord request = new AccessRequestRecord(VALID_CARD_NUMBER, roomId);
    
    when(cardDao.findByCardNumber(VALID_CARD_NUMBER)).thenReturn(Optional.of(mockCard));
    when(bookingDao.findValidBooking(eq(VALID_CARD_NUMBER), eq(roomId), any(LocalDateTime.class)))
      .thenReturn(null);
    
    // Act
    AccessResponseRecord response = accessService.validateAccess(request);
    
    // Assert
    assertFalse(response.accessGranted());
  }
  
  @Test
  void validateAccess_ValidCardButNoBooking() {
    // Arrange
    Long roomId = 1L;
    AccessRequestRecord request = new AccessRequestRecord(VALID_CARD_NUMBER, roomId);
    
    when(cardDao.findByCardNumber(VALID_CARD_NUMBER)).thenReturn(Optional.of(mockCard));
    when(bookingDao.findValidBooking(eq(VALID_CARD_NUMBER), eq(roomId), any(LocalDateTime.class)))
      .thenReturn(null);
    
    // Act
    AccessResponseRecord response = accessService.validateAccess(request);
    
    // Assert
    assertFalse(response.accessGranted());
  }
}
</file>

<file path="src/test/java/com/roomreservation/BookingServiceTest.java">
package com.roomreservation;

import com.roomreservation.model.BookingEntity;
import com.roomreservation.model.RoomEntity;
import com.roomreservation.model.UserEntity;
import com.roomreservation.record.BookingCommandRecord;
import com.roomreservation.record.BookingRecord;
import com.roomreservation.record.RoomRecord;
import com.roomreservation.repository.BookingDao;
import com.roomreservation.repository.RoomDao;
import com.roomreservation.repository.UserDao;
import com.roomreservation.service.BookingService;
import com.roomreservation.service.RoomService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class BookingServiceTest {
  @Mock
  private BookingDao bookingDao;
  @Mock
  private RoomDao roomDao;
  @Mock
  private UserDao userDao;
  @Mock
  private RoomService roomService;
  
  @InjectMocks
  private BookingService bookingService;
  
  private BookingEntity mockBooking;
  private RoomEntity mockRoom;
  private UserEntity mockUser;
  private LocalDateTime startTime;
  private LocalDateTime endTime;
  
  @BeforeEach
  void setUp() {
    mockUser = new UserEntity();
    mockUser.setId(1L);
    mockUser.setEmail("test@test.com");
    
    mockRoom = new RoomEntity();
    mockRoom.setId(1L);
    mockRoom.setName("Test Room");
    mockRoom.setCapacity(10);
    
    startTime = LocalDateTime.now().plusHours(1);
    endTime = startTime.plusHours(2);
    
    mockBooking = new BookingEntity();
    mockBooking.setId(1L);
    mockBooking.setStartTime(startTime);
    mockBooking.setEndTime(endTime);
    mockBooking.setRoomEntity(mockRoom);
    mockBooking.setUserEntity(mockUser);
  }
  
  @Test
  void createBooking_Success() {
    BookingCommandRecord command = new BookingCommandRecord(
      startTime, endTime, mockRoom.getId(), mockUser.getId()
    );
    
    when(roomDao.findById(mockRoom.getId())).thenReturn(Optional.of(mockRoom));
    when(userDao.findById(mockUser.getId())).thenReturn(Optional.of(mockUser));
    when(roomService.getAvailableRooms(any(), any()))
      .thenReturn(List.of(new RoomRecord(mockRoom.getId(), mockRoom.getName(),
        mockRoom.getCapacity(), List.of())));
    when(bookingDao.save(any())).thenReturn(mockBooking);
    
    BookingRecord result = bookingService.createBooking(command);
    
    assertNotNull(result);
    assertEquals(mockBooking.getId(), result.id());
    assertEquals(mockRoom.getId(), result.roomId());
    assertEquals(mockUser.getId(), result.userId());
  }
  
  @Test
  void createBooking_RoomNotAvailable() {
    BookingCommandRecord command = new BookingCommandRecord(
      startTime, endTime, mockRoom.getId(), mockUser.getId()
    );
    
    when(roomDao.findById(mockRoom.getId())).thenReturn(Optional.of(mockRoom));
    when(userDao.findById(mockUser.getId())).thenReturn(Optional.of(mockUser));
    when(roomService.getAvailableRooms(any(), any())).thenReturn(List.of());
    
    assertThrows(RuntimeException.class, () -> bookingService.createBooking(command));
  }
}
</file>

<file path="src/test/java/com/roomreservation/RoomServiceTest.java">
package com.roomreservation.service;

import com.roomreservation.model.BookingEntity;
import com.roomreservation.model.RoomEntity;
import com.roomreservation.model.UserEntity;
import com.roomreservation.record.RoomRecord;
import com.roomreservation.repository.BookingDao;
import com.roomreservation.repository.RoomDao;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class RoomServiceTest {
  @Mock
  private RoomDao roomDao;
  
  @Mock
  private BookingDao bookingDao;
  
  @InjectMocks
  private RoomService roomService;
  
  private RoomEntity mockRoom;
  private UserEntity mockUser;
  private List<BookingEntity> mockBookings;
  
  @BeforeEach
  void setUp() {
    // Setup mock user
    mockUser = new UserEntity();
    mockUser.setId(1L);
    mockUser.setFirstName("Test");
    mockUser.setLastName("User");
    mockUser.setEmail("test@test.com");
    
    // Setup mock room
    mockRoom = new RoomEntity();
    mockRoom.setId(1L);
    mockRoom.setName("Test Room");
    mockRoom.setCapacity(10);
    
    // Setup mock bookings list
    mockBookings = new ArrayList<>();
    mockRoom.setBookingEntities(mockBookings);
  }
  
  @Test
  void createRoom_Success() {
    // Arrange
    RoomRecord roomRecord = new RoomRecord(null, "Test Room", 10, List.of());
    when(roomDao.save(any(RoomEntity.class))).thenReturn(mockRoom);
    
    // Act
    RoomRecord result = roomService.createRoom(roomRecord);
    
    // Assert
    assertNotNull(result);
    assertEquals(mockRoom.getName(), result.name());
    assertEquals(mockRoom.getCapacity(), result.capacity());
  }
  
  @Test
  void getRoomById_Success() {
    // Arrange
    when(roomDao.findById(1L)).thenReturn(Optional.of(mockRoom));
    
    // Act
    RoomRecord result = roomService.getRoomById(1L);
    
    // Assert
    assertNotNull(result);
    assertEquals(mockRoom.getId(), result.id());
    assertEquals(mockRoom.getName(), result.name());
  }
  
  @Test
  void getRoomById_NotFound() {
    // Arrange
    when(roomDao.findById(999L)).thenReturn(Optional.empty());
    
    // Act & Assert
    assertThrows(RuntimeException.class, () -> roomService.getRoomById(999L));
  }
  
  @Test
  void getAvailableRooms_Success() {
    // Arrange
    LocalDateTime startTime = LocalDateTime.now().plusHours(1);
    LocalDateTime endTime = startTime.plusHours(2);
    
    when(roomDao.findAll()).thenReturn(List.of(mockRoom));
    
    // Act
    List<RoomRecord> result = roomService.getAvailableRooms(startTime, endTime);
    
    // Assert
    assertFalse(result.isEmpty());
    assertEquals(1, result.size());
    assertEquals(mockRoom.getId(), result.get(0).id());
  }
  
  @Test
  void getAvailableRooms_WithConflictingBooking() {
    // Arrange
    LocalDateTime now = LocalDateTime.now();
    LocalDateTime startTime = now.plusHours(1);
    LocalDateTime endTime = startTime.plusHours(2);
    
    // Create a conflicting booking with proper user association
    BookingEntity conflictingBooking = new BookingEntity();
    conflictingBooking.setId(1L);
    conflictingBooking.setStartTime(startTime.minusMinutes(30));
    conflictingBooking.setEndTime(endTime.plusMinutes(30));
    conflictingBooking.setRoomEntity(mockRoom);
    conflictingBooking.setUserEntity(mockUser); // Set the user entity
    mockBookings.add(conflictingBooking);
    
    when(roomDao.findAll()).thenReturn(List.of(mockRoom));
    
    // Act
    List<RoomRecord> result = roomService.getAvailableRooms(startTime, endTime);
    
    // Assert
    assertTrue(result.isEmpty());
  }
  
  @Test
  void updateRoom_Success() {
    // Arrange
    Long roomId = 1L;
    RoomRecord updateRecord = new RoomRecord(roomId, "Updated Room", 15, List.of());
    when(roomDao.findById(roomId)).thenReturn(Optional.of(mockRoom));
    when(roomDao.save(any(RoomEntity.class))).thenReturn(mockRoom);
    
    // Act
    RoomRecord result = roomService.updateRoom(roomId, updateRecord);
    
    // Assert
    assertNotNull(result);
    assertEquals(updateRecord.name(), result.name());
    assertEquals(updateRecord.capacity(), result.capacity());
  }
  
  @Test
  void getAllRooms_Success() {
    // Arrange
    List<RoomEntity> mockRooms = List.of(mockRoom);
    when(roomDao.findAll()).thenReturn(mockRooms);
    
    // Act
    List<RoomRecord> results = roomService.getAllRooms();
    
    // Assert
    assertFalse(results.isEmpty());
    assertEquals(1, results.size());
    assertEquals(mockRoom.getId(), results.get(0).id());
    assertEquals(mockRoom.getName(), results.get(0).name());
  }
}
</file>

<file path="src/test/java/com/roomreservation/UserServiceTest.java">
package com.roomreservation;

import com.roomreservation.model.CardEntity;
import com.roomreservation.model.UserEntity;
import com.roomreservation.repository.CardDao;
import com.roomreservation.repository.UserDao;
import com.roomreservation.service.UserService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {
  @Mock
  private UserDao userDao;
  @Mock
  private CardDao cardDao;
  
  @InjectMocks
  private UserService userService;
  
  private UserEntity mockUser;
  private CardEntity mockCard;
  
  @BeforeEach
  void setUp() {
    mockUser = new UserEntity();
    mockUser.setId(1L);
    mockUser.setFirstName("Test");
    mockUser.setLastName("User");
    mockUser.setEmail("test@test.com");
    mockUser.setPassword("password");
    
    mockCard = new CardEntity();
    mockCard.setId(1L);
    mockCard.setCardNumber("CARD-TEST001");
    mockCard.setUserEntity(mockUser);
    
    mockUser.setCardEntity(mockCard);
  }
  
  @Test
  void createUser_Success() {
    when(userDao.findByEmailIgnoreCase(mockUser.getEmail())).thenReturn(null);
    when(userDao.save(any(UserEntity.class))).thenReturn(mockUser);
    when(cardDao.save(any(CardEntity.class))).thenReturn(mockCard);
    
    UserEntity result = userService.createUser(mockUser);
    
    assertNotNull(result);
    assertEquals(mockUser.getEmail(), result.getEmail());
    assertNotNull(result.getCardEntity());
  }
  
  @Test
  void createUser_EmailExists() {
    when(userDao.findByEmailIgnoreCase(mockUser.getEmail())).thenReturn(mockUser);
    
    assertThrows(RuntimeException.class, () -> userService.createUser(mockUser));
  }
}
</file>

<file path="build.gradle.kts">
plugins {
    java
    id("org.springframework.boot") version "3.4.0"
    id("io.spring.dependency-management") version "1.1.6"
    id("com.github.spotbugs") version "5.2.1"
    id("checkstyle")
}

group = "com.roomreservation"
version = "0.0.1-SNAPSHOT"

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

spotbugs {
    toolVersion.set("4.8.3")
    excludeFilter.set(file("config/spotbugs/exclude.xml"))
    ignoreFailures.set(true)
}

checkstyle {
    toolVersion = "10.12.7"
    maxWarnings = 0
}

repositories {
    maven { url = uri("https://repo.spring.io/milestone") }
    mavenCentral()
}

extra["springCloudVersion"] = "2024.0.0-RC1"

dependencies {
    implementation("com.h2database:h2")
    implementation("org.springframework.boot:spring-boot-starter-actuator")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-integration")
    implementation("org.springframework.boot:spring-boot-starter-security")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-webflux")
    implementation("org.springframework.cloud:spring-cloud-function-web")
    implementation("org.springframework.cloud:spring-cloud-starter")
    implementation("org.springframework.cloud:spring-cloud-starter-task")
    implementation("org.springframework.integration:spring-integration-http")
    implementation("org.springframework.integration:spring-integration-jpa")
    implementation("org.springframework.integration:spring-integration-webflux")
    implementation("org.springframework.security:spring-security-messaging")
    developmentOnly("org.springframework.boot:spring-boot-devtools")
    implementation("com.h2database:h2")
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.projectreactor:reactor-test")
    testImplementation("org.springframework.integration:spring-integration-test")
    testImplementation("org.springframework.security:spring-security-test")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
    compileOnly("org.projectlombok:lombok:1.18.36")
    annotationProcessor("org.projectlombok:lombok:1.18.36")
    testCompileOnly ("org.projectlombok:lombok:1.18.36")
    testAnnotationProcessor ("org.projectlombok:lombok:1.18.36")
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.cloud:spring-cloud-dependencies:${property("springCloudVersion")}")
    }
}

tasks.withType<Test> {
    useJUnitPlatform()
}

tasks.withType<Checkstyle>().configureEach {
    reports {
        xml.required.set(true)
        html.required.set(true)
    }
}
</file>

<file path="Dockerfile">
FROM eclipse-temurin:17-jdk

WORKDIR /app

COPY . .
RUN chmod +x gradlew
RUN ./gradlew build -x test

EXPOSE 8080

CMD ["java", "-jar", "build/libs/RoomReservation-0.0.1-SNAPSHOT.jar"]
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="HELP.md">
# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

* [Official Gradle documentation](https://docs.gradle.org)
* [Spring Boot Gradle Plugin Reference Guide](https://docs.spring.io/spring-boot/3.4.0/gradle-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.4.0/gradle-plugin/packaging-oci-image.html)
* [Spring Integration AMQP Module Reference Guide](https://docs.spring.io/spring-integration/reference/amqp.html)
* [Spring Integration JPA Module Reference Guide](https://docs.spring.io/spring-integration/reference/jpa.html)
* [Spring Integration Test Module Reference Guide](https://docs.spring.io/spring-integration/reference/testing.html)
* [Spring Integration Security Module Reference Guide](https://docs.spring.io/spring-integration/reference/security.html)
* [Spring Integration HTTP Module Reference Guide](https://docs.spring.io/spring-integration/reference/http.html)
* [Spring Integration WebFlux Module Reference Guide](https://docs.spring.io/spring-integration/reference/webflux.html)
* [Spring Boot Actuator](https://docs.spring.io/spring-boot/3.4.0/reference/actuator/index.html)
* [Spring for RabbitMQ](https://docs.spring.io/spring-boot/3.4.0/reference/messaging/amqp.html)
* [Function](https://docs.spring.io/spring-cloud-function/reference/)
* [Cloud Bootstrap](https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/application-context-services.html)
* [Task](https://docs.spring.io/spring-cloud-task/reference/)
* [Spring Data JPA](https://docs.spring.io/spring-boot/3.4.0/reference/data/sql.html#data.sql.jpa-and-spring-data)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.4.0/reference/using/devtools.html)
* [Spring Integration](https://docs.spring.io/spring-boot/3.4.0/reference/messaging/spring-integration.html)
* [Spring Security](https://docs.spring.io/spring-boot/3.4.0/reference/web/spring-security.html)
* [Validation](https://docs.spring.io/spring-boot/3.4.0/reference/io/validation.html)
* [Spring Web](https://docs.spring.io/spring-boot/3.4.0/reference/web/servlet.html)
* [Spring Reactive Web](https://docs.spring.io/spring-boot/3.4.0/reference/web/reactive.html)

### Guides

The following guides illustrate how to use some features concretely:

* [Building a RESTful Web Service with Spring Boot Actuator](https://spring.io/guides/gs/actuator-service/)
* [Messaging with RabbitMQ](https://spring.io/guides/gs/messaging-rabbitmq/)
* [Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/)
* [Integrating Data](https://spring.io/guides/gs/integration/)
* [Securing a Web Application](https://spring.io/guides/gs/securing-web/)
* [Spring Boot and OAuth2](https://spring.io/guides/tutorials/spring-boot-oauth2/)
* [Authenticating a User with LDAP](https://spring.io/guides/gs/authenticating-ldap/)
* [Validation](https://spring.io/guides/gs/validating-form-input/)
* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)
* [Building a Reactive RESTful Web Service](https://spring.io/guides/gs/reactive-rest-service/)

### Additional Links

These additional references should also help you:

* [Gradle Build Scans – insights for your project's build](https://scans.gradle.com#gradle)
* [Various sample apps using Spring Cloud Function](https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples)
</file>

<file path="settings.gradle.kts">
rootProject.name = "RoomReservation"
</file>

</files>
